/**
 * Mule Cassandra Connector
 *
 * Copyright (c) MuleSoft, Inc.  All rights reserved.  http://www.mulesoft.com
 *
 * The software in this package is published under the terms of the CPAL v1.0
 * license, a copy of which has been included with this distribution in the
 * LICENSE.txt file.
 */

/**
 * This file was automatically generated by the Mule Development Kit
 */
package com.mulesoft.mule.cassandradb;


import org.apache.cassandra.thrift.*;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.thrift.protocol.TBinaryProtocol;
import org.apache.thrift.protocol.TProtocol;
import org.apache.thrift.transport.TFramedTransport;
import org.apache.thrift.transport.TSocket;
import org.apache.thrift.transport.TTransport;
import org.mule.api.ConnectionException;
import org.mule.api.annotations.*;
import org.mule.api.annotations.display.Placement;
import org.mule.api.annotations.param.ConnectionKey;
import org.mule.api.annotations.param.Default;
import org.mule.api.annotations.param.Optional;
import org.mule.api.annotations.param.Payload;

import java.nio.ByteBuffer;
import java.util.*;

/**
 * Cloud Connector
 *
 * @author MuleSoft, Inc.
 */
@Connector(name = "cassandradb", schemaVersion = "3.2")
public class CassandraDBConnector {
    protected static final Log logger = LogFactory.getLog(CassandraDBConnector.class);

    /**
     * Host name or IP address
     */
    @Configurable
    private String host;

    /**
     * Port (default is 9160)
     */
    @Configurable
    @Default("9160")
    @Optional
    private int port = 9160;

    /**
     * Cassandra keyspace
     */
    @Configurable
    private String keyspace;

    /**
     * Consistency Level. Can be one of ANY, ONE (default), TWO, THREE, QUORUM, LOCAL_QUORUM, EACH_QUORUM, ALL.
     * See http://wiki.apache.org/cassandra/API for more details.
     */
    @Configurable
    @Optional
    @Default("ONE")
    private ConsistencyLevel consistencyLevel;

    private TTransport tr;
    private Cassandra.Client client;

    /**
     * Connect
     *
     * @param username A username
     * @param password A password
     * @throws ConnectionException
     */
    @Connect
    public void connect(@ConnectionKey String username, String password)
            throws ConnectionException {
        try {
            logger.debug("Attempting to connect to Cassandra");
            tr = new TFramedTransport(new TSocket(host, port));
            TProtocol proto = new TBinaryProtocol(tr);
            client = new Cassandra.Client(proto);
            tr.open();
            client.set_keyspace(keyspace);
            logger.debug("Connection created: " + tr);
        } catch (Throwable e) {
            logger.error("Unable to connect to Casssandra DB instance", e);
            throw new org.mule.api.ConnectionException(org.mule.api.ConnectionExceptionCode.UNKNOWN, null, e.getMessage(), e);
        }
    }

    /**
     * Disconnect
     */
    @Disconnect
    public void disconnect() {
        if (isConnected()) {
            try {
                tr.flush();
                tr.close();
            } catch (Exception e) {
                logger.error("Exception thrown while trying to disconnect:", e);
            }
        }
    }

    /**
     * Are we connected
     */
    @ValidateConnection
    public boolean isConnected() {
        return (tr != null && tr.isOpen());
    }

    /**
     * Are we connected
     */
    @ConnectionIdentifier
    public String connectionId() {
        return "001";
    }

    /**
     * Insert object into the database
     * <p/>
     * {@sample.xml ../../../doc/CassandraDB-connector.xml.sample cassandradb:insert}
     *
     * @param content Content to be inserted into the database. Must be an instance of Map in the following format:
     *                <p/>
     *                {
     *                "ToyStores" : {                           - Column Family
     *                "Ohio Store" : {                        - RowKey
     *                "Transformer" : {                     - SuperColumn
     *                "Price" : "29.99",                  - Column
     *                "Section" : "Action Figures"
     *                }
     *                "GumDrop" : {
     *                "Price" : "0.25",
     *                "Section" : "Candy"
     *                }
     *                "MatchboxCar" : {
     *                "Price" : "1.49",
     *                "Section" : "Vehicles"
     *                }
     *                }
     *                "New York Store" : {
     *                "JawBreaker" : {
     *                "Price" : "4.25",
     *                "Section" : "Candy"
     *                }
     *                "MatchboxCar" : {
     *                "Price" : "8.79",
     *                "Section" : "Vehicles"
     *                }
     *                }
     *                }
     *                }
     *                * @param password A password
     * @return Same content
     * @throws Exception IOException
     */
    @Processor
    public Map insert(@Payload Map content)
            throws Exception {
        logger.debug("Inserting the data: " + content);

        //Iterate through ColumnFamilies
        for (Object key : content.keySet()) {
            String nextCFName = (String) key;

            Map<ByteBuffer, Map<String, List<Mutation>>> mutationsMap = new HashMap<ByteBuffer, Map<String, List<Mutation>>>();

            try {
                CfDef cfDef = new CfDef(keyspace, nextCFName);
                cfDef.column_type = "Super";
                client.system_add_column_family(cfDef);
            } catch (Exception e) {
                //Assume CF already exists:
                logger.warn("ColumnFamily '" + nextCFName + "' already exists; message: " + e.getMessage());
            }

            //Get SuperColumns of this CF
            Map superColumnsMap = (Map) content.get(nextCFName);
            //Iterate over RowKeys
            for (Object rowKey : superColumnsMap.keySet()) {

                Map<String, List<Mutation>> insertDataMap = new HashMap<String, List<Mutation>>();
                List<Mutation> rowData = new ArrayList<Mutation>();

                String nextRowKey = (String) rowKey;
                Map nextSCMap = (Map) superColumnsMap.get(nextRowKey);
                //Iterate over super column names
                for (Object superColumnName : nextSCMap.keySet()) {
                    String nextSCName = (String) superColumnName;
                    List<Column> columnsList = new ArrayList<Column>();
                    //Get Map of Columns
                    Map columnsMap = (Map) nextSCMap.get(nextSCName);
                    for (Object columnName : columnsMap.keySet()) {
                        String nextColumnName = (String) columnName;
                        Object nextColumnValue = columnsMap.get(nextColumnName);

                        Column nextColumn = new Column(CassandraDBUtils.toByteBuffer(nextColumnName));
                        nextColumn.setValue(CassandraDBUtils.toByteBuffer(nextColumnValue));
                        nextColumn.setTimestamp(System.currentTimeMillis());
                        columnsList.add(nextColumn);
                    }

                    SuperColumn nextSuperColumn = new SuperColumn(CassandraDBUtils.toByteBuffer(nextSCName),
                            columnsList);
                    ColumnOrSuperColumn columnOrSuperColumn = new ColumnOrSuperColumn();
                    columnOrSuperColumn.setSuper_column(nextSuperColumn);
                    Mutation m = new Mutation();
                    m.setColumn_or_supercolumn(columnOrSuperColumn);

                    rowData.add(m);
                }

                insertDataMap.put(nextCFName, rowData);
                mutationsMap.put(CassandraDBUtils.toByteBuffer(nextRowKey), insertDataMap);
            }

            client.batch_mutate(mutationsMap, this.getConsistencyLevel());
        }

        return content;
    }

    /**
     * Get the group of columns contained by column_parent  (either a ColumnFamily name or a ColumnFamily/SuperColumn name pair)
     * specified by the given SlicePredicate (start, finish, reversed and count) parameters.
     * <p/>
     * {@sample.xml ../../../doc/CassandraDB-connector.xml.sample cassandradb:get-slice}
     *
     * @param rowKey       the row key
     * @param columnParent Path to the column - must be a name of the ColumnFamily or ColumnFamily:SuperColumn pair
     * @param start        The column name to start the slice with.
     * @param finish       The column name to stop the slice at.
     * @param reversed     Whether the results should be ordered in reversed order. Similar to ORDER BY blah DESC in SQL.
     * @param count        How many columns to return.
     * @param columnSerializers Serializers for each column
     * @return the result as a JSON node
     * @throws Exception Exception
     */
    @Processor(name = "get-slice")
    public Object getSlice(String rowKey, String columnParent, @Optional  String start,
                           @Optional  String finish,
                           @Optional @Default("false") boolean reversed, int count,
                           @Optional List<ColumnSerializer> columnSerializers) throws Exception {
        logger.debug("Get Slice: ROW KEY= " + rowKey + " COLUMN PARENT=" + columnParent +
                " START=" + start + " FINISH=" + finish + " REVERSED=" + reversed + " COUNT=" + count);

        String[] pathElements = columnParent.split(":");

        ColumnParent cParent = new ColumnParent();
        if (pathElements.length > 0)
            cParent = cParent.setColumn_family(pathElements[0]);
        if (pathElements.length > 1)
            cParent = cParent.setSuper_column(CassandraDBUtils.toByteBuffer(pathElements[1]));

        SlicePredicate predicate = new SlicePredicate();
        SliceRange range = new SliceRange();
        if (start == null) {
             range.setStart(new byte[0]);
        } else {
            range.setStart(CassandraDBUtils.toByteBuffer(start));
        }

        if (finish == null) {
            range.setFinish(new byte[0]);
        } else {
            range.setFinish(CassandraDBUtils.toByteBuffer(finish));
        }
        range.setCount(count);
        range.setReversed(reversed);

        predicate.setSlice_range(range);
        List<ColumnOrSuperColumn> columnsByKey = client.get_slice(CassandraDBUtils.toByteBuffer(rowKey),
                cParent, predicate, this.getConsistencyLevel());

        return CassandraDBUtils.listOfColumnsToMap(columnsByKey, columnSerializers);
    }

    /**
     * Get Column or SuperColumn by the path
     * <p/>
     * {@sample.xml ../../../doc/CassandraDB-connector.xml.sample cassandradb:get}
     *
     * @param rowKey            the row key
     * @param columnPath        Path to the column - must be in the form of ColumnFamily:SuperColumn:Column
     * @param columnSerializers Serializers for each column
     * @return the result as a JSON node
     * @throws Exception IOException
     */
    @Processor
    public Object get(String rowKey, String columnPath, @Placement(group = "Columns")
    @Optional List<ColumnSerializer> columnSerializers) throws Exception {
        logger.debug("Retrieving the data from column path: " + columnPath);

        ColumnPath cPath = _parseColumnPath(columnPath);
        ColumnOrSuperColumn result = client.get(CassandraDBUtils.toByteBuffer(rowKey), cPath, this.getConsistencyLevel());

        logger.debug("ColumnPath " + columnPath + " ; result is : " + result);

        return CassandraDBUtils.columnOrSuperColumnToMap(result, columnSerializers);
    }

    /**
     * Remove data from the row specified by key at the granularity specified by column_path, and the given timestamp.
     * Note that all the values in column_path besides column_path.column_family are truly optional: you can remove the entire row
     * by just specifying the ColumnFamily, or you can remove a SuperColumn or a single Column by specifying those levels too.
     * Note that the timestamp is needed, so that if the commands are replayed in a different order on different nodes, the same result is produced.
     * <p/>
     * {@sample.xml ../../../doc/CassandraDB-connector.xml.sample cassandradb:remove}
     *
     * @param rowKey     the row key
     * @param columnPath Path to the column - must be in the form of ColumnFamily:SuperColumn:Column
     * @throws Exception IOException
     */
    @Processor
    public void remove(String rowKey, String columnPath) throws Exception {
        ColumnPath cPath = _parseColumnPath(columnPath);
        client.remove(CassandraDBUtils.toByteBuffer(rowKey), cPath, new Date().getTime(), this.getConsistencyLevel());
    }

    public String getHost() {
        return this.host;
    }

    public void setHost(String host) {
        this.host = host;
    }

    public int getPort() {
        return this.port;
    }

    public void setPort(int port) {
        this.port = port;
    }

    public String getKeyspace() {
        return this.keyspace;
    }

    public void setKeyspace(String keyspace) {
        this.keyspace = keyspace;
    }

    public ConsistencyLevel getConsistencyLevel() {
        return this.consistencyLevel;
    }

    public void setConsistencyLevel(ConsistencyLevel consistencyLevel) {
        this.consistencyLevel = consistencyLevel;
    }

    private ColumnPath _parseColumnPath(String columnPath) throws java.io.UnsupportedEncodingException {
        String[] pathElements = columnPath.split(":");

        ColumnPath cPath = new ColumnPath();
        if (pathElements.length > 0)
            cPath = cPath.setColumn_family(pathElements[0]);
        if (pathElements.length > 1)
            cPath = cPath.setSuper_column(CassandraDBUtils.toByteBuffer(pathElements[1]));
        if (pathElements.length > 2)
            cPath = cPath.setColumn(CassandraDBUtils.toByteBuffer(pathElements[2]));

        return cPath;
    }

}
